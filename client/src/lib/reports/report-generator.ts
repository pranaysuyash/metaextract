/**
 * Professional Reports Generator - PDF report engine and templates
 */

import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import { format } from 'date-fns';

// Types for report data
export interface ReportData {
  title: string;
  description: string;
  dateRange: [Date, Date];
  metrics: ReportMetric[];
  charts: ReportChart[];
  tables: ReportTable[];
  insights: string[];
  recommendations: string[];
  metadata: {
    generatedAt: Date;
    generatedBy: string;
    reportId: string;
  };
}

export interface ReportMetric {
  name: string;
  value: string | number;
  change?: string;
  trend?: 'up' | 'down';
  description?: string;
}

export interface ReportChart {
  title: string;
  type: 'bar' | 'line' | 'pie' | 'area';
  data: any[];
  labels: string[];
}

export interface ReportTable {
  title: string;
  headers: string[];
  rows: any[][];
}

export interface ReportTemplate {
  id: string;
  name: string;
  description: string;
  category: 'executive' | 'operational' | 'analytical' | 'compliance';
  defaultMetrics: string[];
  defaultCharts: string[];
  defaultTables: string[];
}

export class ReportGenerator {
  /**
   * Generate a PDF report
   */
  static async generatePDFReport(data: ReportData): Promise<Blob> {
    const doc = new jsPDF();
    
    // Add title
    doc.setFontSize(22);
    doc.text(data.title, 20, 20);
    
    // Add description
    doc.setFontSize(12);
    doc.setTextColor(100, 100, 100);
    doc.text(data.description, 20, 35);
    
    // Add date range
    const dateStr = `Report Period: ${format(data.dateRange[0], 'MMM d, yyyy')} - ${format(data.dateRange[1], 'MMM d, yyyy')}`;
    doc.text(dateStr, 20, 45);
    
    // Add metadata
    const metadataStr = `Generated: ${format(data.metadata.generatedAt, 'MMM d, yyyy HH:mm')} | Generated by: ${data.metadata.generatedBy}`;
    doc.text(metadataStr, 20, 55);
    
    // Add metrics section
    let currentY = 70;
    doc.setFontSize(16);
    doc.setTextColor(0, 0, 0);
    doc.text('Key Metrics', 20, currentY);
    
    currentY += 10;
    doc.setDrawColor(200, 200, 200);
    doc.line(20, currentY, 190, currentY);
    currentY += 15;
    
    // Add metrics in a table format
    const metricRows = data.metrics.map(metric => [
      metric.name,
      metric.value.toString(),
      metric.change || 'N/A',
      metric.description || ''
    ]);
    
    autoTable(doc, {
      startY: currentY,
      head: [['Metric', 'Value', 'Change', 'Description']],
      body: metricRows,
      theme: 'grid',
      styles: { fontSize: 10 },
      headStyles: { fillColor: [59, 130, 246] },
    });
    
    currentY = (doc as any).lastAutoTable.finalY + 15;
    
    // Add insights section
    doc.setFontSize(16);
    doc.text('Key Insights', 20, currentY);
    currentY += 10;
    doc.setDrawColor(200, 200, 200);
    doc.line(20, currentY, 190, currentY);
    currentY += 10;
    
    data.insights.forEach(insight => {
      doc.setFontSize(12);
      doc.setTextColor(0, 0, 0);
      doc.text(`• ${insight}`, 20, currentY);
      currentY += 8;
    });
    
    currentY += 10;
    
    // Add recommendations section
    doc.setFontSize(16);
    doc.text('Recommendations', 20, currentY);
    currentY += 10;
    doc.setDrawColor(200, 200, 200);
    doc.line(20, currentY, 190, currentY);
    currentY += 10;
    
    data.recommendations.forEach(rec => {
      doc.setFontSize(12);
      doc.setTextColor(0, 0, 0);
      doc.text(`• ${rec}`, 20, currentY);
      currentY += 8;
    });
    
    // Add tables if any
    for (const table of data.tables) {
      currentY += 15;
      doc.setFontSize(16);
      doc.text(table.title, 20, currentY);
      currentY += 10;
      doc.setDrawColor(200, 200, 200);
      doc.line(20, currentY, 190, currentY);
      currentY += 15;
      
      autoTable(doc, {
        startY: currentY,
        head: [table.headers],
        body: table.rows,
        theme: 'grid',
        styles: { fontSize: 10 },
        headStyles: { fillColor: [59, 130, 246] },
      });
      
      currentY = (doc as any).lastAutoTable.finalY + 15;
    }
    
    // Add footer
    const pageCount = doc.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(10);
      doc.setTextColor(150);
      doc.text(`Page ${i} of ${pageCount}`, 20, doc.internal.pageSize.height - 10);
    }
    
    return doc.output('blob');
  }

  /**
   * Generate a CSV report
   */
  static generateCSVReport(data: ReportData): string {
    let csv = '';
    
    // Add report header
    csv += `Report: ${data.title}\n`;
    csv += `Description: ${data.description}\n`;
    csv += `Date Range: ${format(data.dateRange[0], 'yyyy-MM-dd')} to ${format(data.dateRange[1], 'yyyy-MM-dd')}\n`;
    csv += `Generated: ${format(data.metadata.generatedAt, 'yyyy-MM-dd HH:mm:ss')}\n`;
    csv += `Generated By: ${data.metadata.generatedBy}\n\n`;
    
    // Add metrics
    csv += 'METRICS\n';
    csv += 'Name,Value,Change,Description\n';
    data.metrics.forEach(metric => {
      csv += `"${metric.name}","${metric.value}","${metric.change || ''}","${metric.description || ''}"\n`;
    });
    csv += '\n';
    
    // Add insights
    csv += 'INSIGHTS\n';
    data.insights.forEach(insight => {
      csv += `"${insight}"\n`;
    });
    csv += '\n';
    
    // Add recommendations
    csv += 'RECOMMENDATIONS\n';
    data.recommendations.forEach(rec => {
      csv += `"${rec}"\n`;
    });
    csv += '\n';
    
    // Add tables
    data.tables.forEach(table => {
      csv += `${table.title.toUpperCase()}\n`;
      csv += table.headers.join(',') + '\n';
      table.rows.forEach(row => {
        csv += row.map(cell => `"${cell}"`).join(',') + '\n';
      });
      csv += '\n';
    });
    
    return csv;
  }

  /**
   * Generate a JSON report
   */
  static generateJSONReport(data: ReportData): string {
    return JSON.stringify(data, null, 2);
  }

  /**
   * Get available report templates
   */
  static getReportTemplates(): ReportTemplate[] {
    return [
      {
        id: 'executive-summary',
        name: 'Executive Summary',
        description: 'High-level overview with key metrics and insights',
        category: 'executive',
        defaultMetrics: ['total-uploads', 'conversions', 'revenue', 'active-users'],
        defaultCharts: ['uploads-trend', 'revenue-trend'],
        defaultTables: ['top-performing-segments']
      },
      {
        id: 'operational-metrics',
        name: 'Operational Metrics',
        description: 'Detailed metrics for operational teams',
        category: 'operational',
        defaultMetrics: ['processing-time', 'error-rate', 'uptime', 'throughput'],
        defaultCharts: ['performance-trend', 'error-rate-trend'],
        defaultTables: ['system-metrics', 'error-breakdown']
      },
      {
        id: 'user-analytics',
        name: 'User Analytics',
        description: 'User behavior and engagement metrics',
        category: 'analytical',
        defaultMetrics: ['new-users', 'retention-rate', 'session-duration', 'conversion-rate'],
        defaultCharts: ['user-growth', 'engagement-trend'],
        defaultTables: ['user-segmentation', 'feature-usage']
      },
      {
        id: 'compliance-report',
        name: 'Compliance Report',
        description: 'Regulatory and compliance metrics',
        category: 'compliance',
        defaultMetrics: ['data-retention', 'access-audits', 'privacy-compliance', 'security-incident'],
        defaultCharts: ['compliance-trend', 'audit-logs'],
        defaultTables: ['access-logs', 'data-retention']
      }
    ];
  }

  /**
   * Generate a report using a template
   */
  static generateReportFromTemplate(
    templateId: string,
    dateRange: [Date, Date],
    additionalData: Partial<ReportData> = {}
  ): ReportData {
    const templates = this.getReportTemplates();
    const template = templates.find(t => t.id === templateId);
    
    if (!template) {
      throw new Error(`Template with ID ${templateId} not found`);
    }
    
    // Generate mock data based on template
    const reportData: ReportData = {
      title: `${template.name} Report`,
      description: template.description,
      dateRange,
      metrics: this.generateMockMetrics(template.defaultMetrics),
      charts: this.generateMockCharts(template.defaultCharts),
      tables: this.generateMockTables(template.defaultTables),
      insights: this.generateMockInsights(template.category),
      recommendations: this.generateMockRecommendations(template.category),
      metadata: {
        generatedAt: new Date(),
        generatedBy: 'System',
        reportId: `report-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
      },
      ...additionalData
    };
    
    return reportData;
  }

  /**
   * Generate mock metrics based on template requirements
   */
  private static generateMockMetrics(metricTypes: string[]): ReportMetric[] {
    const metrics: ReportMetric[] = [];
    
    for (const type of metricTypes) {
      switch (type) {
        case 'total-uploads':
          metrics.push({
            name: 'Total Uploads',
            value: Math.floor(Math.random() * 10000) + 5000,
            change: `+${(Math.random() * 10).toFixed(1)}%`,
            trend: 'up',
            description: 'Total number of files uploaded'
          });
          break;
        case 'conversions':
          metrics.push({
            name: 'Successful Conversions',
            value: Math.floor(Math.random() * 5000) + 2000,
            change: `+${(Math.random() * 8).toFixed(1)}%`,
            trend: 'up',
            description: 'Successfully processed extractions'
          });
          break;
        case 'revenue':
          metrics.push({
            name: 'Revenue',
            value: `$${(Math.random() * 50000 + 10000).toFixed(0)}`,
            change: `+${(Math.random() * 15).toFixed(1)}%`,
            trend: 'up',
            description: 'Monthly recurring revenue'
          });
          break;
        case 'active-users':
          metrics.push({
            name: 'Active Users',
            value: Math.floor(Math.random() * 2000) + 500,
            change: `+${(Math.random() * 6).toFixed(1)}%`,
            trend: 'up',
            description: 'Unique active users in period'
          });
          break;
        case 'processing-time':
          metrics.push({
            name: 'Avg. Processing Time',
            value: `${(Math.random() * 3 + 1).toFixed(2)}s`,
            change: `-${(Math.random() * 5).toFixed(1)}%`,
            trend: 'down',
            description: 'Average time to process a file'
          });
          break;
        case 'error-rate':
          metrics.push({
            name: 'Error Rate',
            value: `${(Math.random() * 2).toFixed(2)}%`,
            change: `-${(Math.random() * 10).toFixed(1)}%`,
            trend: 'down',
            description: 'Percentage of failed operations'
          });
          break;
        default:
          metrics.push({
            name: type.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
            value: Math.floor(Math.random() * 1000),
            change: `+${(Math.random() * 5).toFixed(1)}%`,
            trend: Math.random() > 0.5 ? 'up' : 'down',
            description: 'General metric'
          });
      }
    }
    
    return metrics;
  }

  /**
   * Generate mock charts based on template requirements
   */
  private static generateMockCharts(chartTypes: string[]): ReportChart[] {
    const charts: ReportChart[] = [];
    
    for (const type of chartTypes) {
      switch (type) {
        case 'uploads-trend':
          charts.push({
            title: 'Uploads Trend',
            type: 'line',
            data: Array.from({ length: 30 }, (_, i) => ({
              date: `Day ${i + 1}`,
              uploads: Math.floor(Math.random() * 500) + 200
            })),
            labels: Array.from({ length: 30 }, (_, i) => `Day ${i + 1}`)
          });
          break;
        case 'revenue-trend':
          charts.push({
            title: 'Revenue Trend',
            type: 'area',
            data: Array.from({ length: 12 }, (_, i) => ({
              month: `Month ${i + 1}`,
              revenue: Math.floor(Math.random() * 10000) + 5000
            })),
            labels: Array.from({ length: 12 }, (_, i) => `Month ${i + 1}`)
          });
          break;
        case 'user-growth':
          charts.push({
            title: 'User Growth',
            type: 'bar',
            data: Array.from({ length: 7 }, (_, i) => ({
              day: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'][i],
              users: Math.floor(Math.random() * 200) + 50
            })),
            labels: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
          });
          break;
        default:
          charts.push({
            title: type.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
            type: 'bar',
            data: Array.from({ length: 5 }, (_, i) => ({
              category: `Category ${i + 1}`,
              value: Math.floor(Math.random() * 100)
            })),
            labels: Array.from({ length: 5 }, (_, i) => `Category ${i + 1}`)
          });
      }
    }
    
    return charts;
  }

  /**
   * Generate mock tables based on template requirements
   */
  private static generateMockTables(tableTypes: string[]): ReportTable[] {
    const tables: ReportTable[] = [];
    
    for (const type of tableTypes) {
      switch (type) {
        case 'top-performing-segments':
          tables.push({
            title: 'Top Performing Segments',
            headers: ['Segment', 'Users', 'Conversions', 'Conversion Rate'],
            rows: [
              ['Enterprise', '1,200', '800', '66.7%'],
              ['Pro', '3,500', '1,200', '34.3%'],
              ['Starter', '5,200', '450', '8.7%'],
              ['Free', '12,000', '120', '1.0%']
            ]
          });
          break;
        case 'user-segmentation':
          tables.push({
            title: 'User Segmentation',
            headers: ['Tier', 'Users', 'Activity', 'Revenue'],
            rows: [
              ['Enterprise', '1,200', 'High', '$15,000'],
              ['Pro', '3,500', 'Medium', '$10,500'],
              ['Starter', '5,200', 'Low', '$2,600'],
              ['Free', '12,000', 'Very Low', '$0']
            ]
          });
          break;
        default:
          tables.push({
            title: type.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
            headers: ['Category', 'Value', 'Change'],
            rows: [
              ['Category A', '100', '+5%'],
              ['Category B', '200', '-2%'],
              ['Category C', '150', '+12%']
            ]
          });
      }
    }
    
    return tables;
  }

  /**
   * Generate mock insights based on category
   */
  private static generateMockInsights(category: ReportTemplate['category']): string[] {
    const insights: string[] = [];
    
    switch (category) {
      case 'executive':
        insights.push(
          'Upload volume increased by 12.5% compared to previous period',
          'Enterprise tier users show highest engagement and conversion rates',
          'Processing performance has improved with reduced error rates'
        );
        break;
      case 'operational':
        insights.push(
          'System uptime remained above 99.9% during reporting period',
          'Processing queue showed no significant bottlenecks',
          'Error rates decreased by 15% compared to previous period'
        );
        break;
      case 'analytical':
        insights.push(
          'User engagement increased by 8% with new feature adoption',
          'Free tier users show potential for conversion to paid tiers',
          'Geographic distribution of users remains consistent'
        );
        break;
      case 'compliance':
        insights.push(
          'All data retention policies were followed during reporting period',
          'No security incidents were reported',
          'Access logs show normal usage patterns'
        );
        break;
    }
    
    return insights;
  }

  /**
   * Generate mock recommendations based on category
   */
  private static generateMockRecommendations(category: ReportTemplate['category']): string[] {
    const recommendations: string[] = [];
    
    switch (category) {
      case 'executive':
        recommendations.push(
          'Consider expanding enterprise tier features to drive higher revenue',
          'Investigate conversion funnel to improve free-to-paid conversion',
          'Plan capacity expansion based on growth trends'
        );
        break;
      case 'operational':
        recommendations.push(
          'Continue monitoring system performance as user base grows',
          'Implement additional error handling for edge cases',
          'Optimize resource allocation based on usage patterns'
        );
        break;
      case 'analytical':
        recommendations.push(
          'Develop targeted onboarding for free tier users',
          'Analyze feature usage to prioritize development efforts',
          'Create user cohorts for more granular analysis'
        );
        break;
      case 'compliance':
        recommendations.push(
          'Review and update security protocols quarterly',
          'Conduct regular compliance audits',
          'Ensure data retention policies are properly enforced'
        );
        break;
    }
    
    return recommendations;
  }
}

export default ReportGenerator;
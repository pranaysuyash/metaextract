
"""
CVE Vulnerability Registry
Registry of Common Vulnerabilities and Exposures (CVE) that can be detected in file metadata.
Used for forensic analysis to identify files created with vulnerable software versions.
Target: ~5,000 fields
"""

from __future__ import annotations

import os
import re
from functools import lru_cache
from importlib.util import module_from_spec, spec_from_file_location
from pathlib import Path
from typing import Any, Dict, List

FALLBACK_CVE_FIELDS: List[str] = [
    "cve.cve_id",
    "cve.cve_year",
    "cve.cve_sequence",
    "cve.description",
    "cve.references",
    "cve.references_url",
    "cve.cvss_version",
    "cve.cvss_base_score",
    "cve.cvss_base_severity",
    "cve.cvss_impact_score",
    "cve.cvss_exploitability_score",
    "cve.cvss_attack_vector",
    "cve.cvss_attack_complexity",
    "cve.cvss_privileges_required",
    "cve.cvss_user_interaction",
    "cve.cvss_scope",
    "cve.cvss_confidentiality",
    "cve.cvss_integrity",
    "cve.cvss_availability",
    "cve.cvss_vector_string",
    "cve.cvss3_version",
    "cve.cvss3_base_score",
    "cve.cvss3_base_severity",
    "cve.cvss4_base_score",
    "cve.cvss4_base_severity",
    "cve.cwe_id",
    "cve.cwe_name",
    "cve.cwe_description",
    "cve.cwe_category",
    "cve.cpe_product",
    "cve.cpe_vendor",
    "cve.cpe_version",
    "cve.cpe_update",
    "cve.cpe_edition",
    "cve.cpe_language",
    "cve.cpe_sw_edition",
    "cve.cpe_target_sw",
    "cve.cpe_target_hw",
    "cve.cpe_other",
]

CVE_PATTERN = re.compile(r"\bCVE-\d{4}-\d{4,7}\b", re.IGNORECASE)
CWE_PATTERN = re.compile(r"\bCWE-\d{1,6}\b", re.IGNORECASE)
CVSS_PATTERN = re.compile(r"\bCVSS:3\.[01]/[A-Z0-9:/._-]+\b", re.IGNORECASE)


@lru_cache(maxsize=1)
def _load_cve_fields() -> List[str]:
    root = Path(__file__).resolve().parents[3]
    inventory_path = root / "scripts" / "inventory_cybersecurity.py"
    if inventory_path.exists():
        try:
            spec = spec_from_file_location("inventory_cybersecurity", inventory_path)
            if spec and spec.loader:
                module = module_from_spec(spec)
                spec.loader.exec_module(module)
                fields = getattr(module, "CVE_FIELDS", None)
                if isinstance(fields, list) and fields:
                    return [str(field) for field in fields]
        except Exception:
            pass
    return list(FALLBACK_CVE_FIELDS)


def get_cve_registry_fields() -> List[str]:
    return _load_cve_fields()


def get_cve_vulnerability_registry_field_count() -> int:
    fields = get_cve_registry_fields()
    return len(fields) if fields else 5000


def extract_cve_vulnerability_registry_metadata(filepath: str) -> Dict[str, Any]:
    '''Extract cve_vulnerability_registry metadata from files'''
    metadata: Dict[str, Any] = {}
    registry = {
        "available": False,
        "fields_extracted": 0,
        "tags": {},
        "unknown_tags": {},
    }
    result = {
        "metadata": metadata,
        "fields_extracted": 0,
        "is_valid_cve_vulnerability_registry": False,
        "extraction_method": "pattern_scan",
        "registry": registry,
    }

    try:
        if not filepath or not os.path.exists(filepath):
            result["error"] = "File not found"
            return result

        try:
            max_bytes = 2_000_000
            with open(filepath, "rb") as handle:
                content = handle.read(max_bytes)
            text = content.decode("utf-8", errors="ignore")
            cve_ids = sorted({match.upper() for match in CVE_PATTERN.findall(text)})
            cwe_ids = sorted({match.upper() for match in CWE_PATTERN.findall(text)})
            cvss_vectors = sorted({match.upper() for match in CVSS_PATTERN.findall(text)})

            years = sorted({cve.split("-")[1] for cve in cve_ids})
            sequences = [cve.split("-", 2)[2] for cve in cve_ids]

            if cve_ids:
                metadata["cve.cve_id"] = cve_ids
                metadata["cve.cve_year"] = years
                metadata["cve.cve_sequence"] = sequences
            if cwe_ids:
                metadata["cve.cwe_id"] = cwe_ids
            if cvss_vectors:
                metadata["cve.cvss_vector_string"] = cvss_vectors

            metadata["cve_detected_count"] = len(cve_ids)
            metadata["cwe_detected_count"] = len(cwe_ids)
            metadata["cvss_vector_count"] = len(cvss_vectors)

            registry["available"] = True
            if cve_ids:
                registry["tags"]["cve_ids"] = {"name": "CVE IDs", "value": cve_ids}
            if cwe_ids:
                registry["tags"]["cwe_ids"] = {"name": "CWE IDs", "value": cwe_ids}
            if cvss_vectors:
                registry["tags"]["cvss_vectors"] = {"name": "CVSS Vectors", "value": cvss_vectors}
            registry["fields_extracted"] = len(registry["tags"])

            result["is_valid_cve_vulnerability_registry"] = True
            result["fields_extracted"] = len(metadata)
        except Exception as e:
            result["error"] = f"cve_vulnerability_registry extraction failed: {str(e)[:200]}"

    except Exception as e:
        result["error"] = f"cve_vulnerability_registry metadata extraction failed: {str(e)[:200]}"

    return result

# Change Review Note (2026-01-18_0014)

- Base commit: `a637e70`
- Threshold: `35%` (env: `LARGE_FILE_CHANGE_PCT`)

## Flagged Files
- `server/storage/index.ts` (delta=122, base=42, pct=290.5%) ← PRIMARY CHANGE
- `docs/LOCAL_DB_SETUP.md`, `.env`, `server/routes/images-mvp.ts`, `server/routes/images-mvp.test.ts` ← SUPPORTING

## Review: Storage Mode Refactoring (Fail-Closed, No Fallback)

### Old Behavior
- **Implicit fallback**: If `DATABASE_URL` missing or `STORAGE_REQUIRE_DATABASE=false`, silently fall back to in-memory storage
- **Risk**: Outages could downgrade to insecure mode; credits wouldn't charge correctly; multi-instance deployments lose consistency
- **Problem**: Fail-open (unsafe default); users don't know if extraction was charged

### New Behavior
- **Explicit mode**: `STORAGE_MODE=db` (default) or `STORAGE_MODE=memory` (dev/test only)
- **Production guard**: `NODE_ENV=production` requires `STORAGE_MODE=db` or server crashes on boot (non-negotiable)
- **Runtime fail-closed**: `assertStorageHealthy()` checks DB before any credit operation; returns 503 if unhealthy
- **Test auto-default**: `NODE_ENV=test` defaults to `STORAGE_MODE=memory` (fast unit tests, no DB dependency)
- **Guarantee**: No silent downgrade; outages appear as service unavailable, not free usage

### Why This Is Better
1. **Security**: Fail-close (503) vs fail-open (free usage) prevents revenue loss on DB failures
2. **Clarity**: Explicit `STORAGE_MODE` env var makes backend choice visible; no ambiguity
3. **Production safety**: Impossible to accidentally run with memory storage in production
4. **Developer experience**: Unit tests auto-use memory mode (no local DB setup burden); integration tests can opt-in to real DB
5. **Money path**: Credit reservation is now gated by health check; prevents processing if DB is down

### Compatibility Risks
- **Breaking change**: Old `STORAGE_REQUIRE_DATABASE` env var is now ignored (must use `STORAGE_MODE`)
- **Deployment**: Production must explicitly set `STORAGE_MODE=db` (defaults to it, but no auto-fallback if DB unavailable)
- **Behavioral change**: If DB was offline during a request, old system would process free; new system returns 503
  - This is intentional: clients should know extraction failed, not assume credits were charged

### How Verified
1. **Tests**: All 18 unit tests pass (images-mvp.test.ts)
   - Mocked `assertStorageHealthy()` (no-op in test mode)
   - Tests auto-use `STORAGE_MODE=memory` (no DB required)
2. **Manual**: Confirmed fail-fast behavior (server crashes on boot if `STORAGE_MODE=db` but DB unavailable)
3. **Logic review**: 
   - Production guard at module load (line 33-36 in server/storage/index.ts)
   - Health check before credit reservation (lines 1756-1760 in server/routes/images-mvp.ts)
   - In-memory mode skips health check (line 82 in server/storage/index.ts, returns early)

### What Was NOT Verified
- Real DB failure during production deployment (simulator DB available for testing, but not full production chaos test)
- Multi-process/distributed locking scenarios (single-node deployments verified; multi-node may need Redis locks)
- Monitoring alerts for 503 responses on money-path endpoints (code in place, but alerting rules must be set up separately)

## Semantic Correctness
✅ **Invariant**: `assertStorageHealthy()` always runs before `reserveCredits()`, preventing charges when DB is unhealthy
✅ **Invariant**: Production enforces `STORAGE_MODE=db` at startup; no way to bypass
✅ **Invariant**: Test environment auto-selects memory mode unless explicitly overridden
✅ **Idempotency**: Retry with same `requestId` still works (held in DB with UNIQUE constraint or in-memory map)



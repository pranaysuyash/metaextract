#!/usr/bin/env python3
"""Generate broadcast/TV/radio metadata field inventory.

This script inventories detailed broadcast metadata fields for:
- ATSC/数字电视 (US digital TV standards)
- DVB/欧洲数字视频 (European digital video standards)
- ISDB/日本数字广播 (Japanese digital broadcasting)
- SMPTE (Society of Motion Picture and Television Engineers)
- MPEG-TS (MPEG Transport Stream)
- Broadcast Automation (scheduling, rundown, production)
- Radio/RDS (FM radio, RDS PS, RT, CT fields)
"""

import json
from pathlib import Path
from typing import Dict, List


def get_atsc_fields() -> List[str]:
    """Get ATSC A/53, A/65, A/71 digital TV metadata fields."""

    fields = [
        "atsc.service_id",
        "atsc.transport_stream_id",
        "atsc.original_network_id",
        "atsc.program_number",
        "atsc.virtual_channel",
        "atsc.major_channel",
        "atsc.minor_channel",
        "atsc.service_type",
        "atsc.service_name",
        "atsc.provider_name",
        "atsc.location_description",
        "atsc.ts_id",
        "atsc.extended_channel_name",
        "atsc.service_language",
        "atsc.logical_channel_number",
        "atsc.short_name",
        "atsc.transport_stream",
        "atsc.pid",
        "atsc.table_id",
        "atsc.table_id_extension",
        "atsc.section_number",
        "atsc.last_section_number",
        "atsc.descriptor_tag",
        "atsc.descriptor_length",
        "atsc.carousel_id",
        "atsc.module_id",
        "atsc.number_of_modules",
        "atsc.module_version",
        "atsc.module_size",
        "atsc.compression_type",
        "atsc.original_network_id",
        "atsc.private_data_specifier",
        "atsc.data_broadcast_id",
        "atsc.denotation",
        "atsc.app_id",
        "atsc.carousel_period",
        "atsc.tap_count",
        "atsc.tap_priority",
        "atsc.component_tag",
        "atsc.stream_type",
        "atsc.elementary_pid",
        "atsc.es_info_length",
        "atsc.service_descriptor",
        "atsc.service_type_descriptor",
        "atsc.service_name_descriptor",
        "atsc.short_service_name_descriptor",
        "atsc.service_location_descriptor",
        "atsc.dx_alignment_level",
        "atsc.dx_maximum_leaky_bucket_depth",
        "atsc.time_of_day",
        "atsc.time_zone",
        "atsc.gps_offset",
        "atsc.daylight_savings",
        "atsc.country_code",
        "atsc.country_code_primary",
        "atsc.region_id",
        "atsc.country_code_secondary",
        "atsc.region_id_secondary",
        "atsc.geographic_subdivision",
        "atsc.channel_cells",
        "atsc.satellite_tsid",
        "atsc.satellite_tsid_countries",
        "atsc.satellite_channel_tv",
        "atsc.satellite_channel_radio",
        "atsc.satellite_data_broadcast",
        "atsc.pcr_pid",
        "atsc.program_association",
        "atsc.program_map",
        "atsc.conditional_access",
        "atsc.network_information",
        "atsc.broadcaster_information",
        "atsc.event_information",
        "atsc.running_status",
        "atsc.free_ca_mode",
        "atsc.descriptor_loop_length",
        "atsc.component_descriptor",
        "atsc.data_component_descriptor",
        "atsc.local_time_offset_descriptor",
        "atsc.mpeg_huffman_table_descriptor",
        "atsc.systems_management_descriptor",
        "atsc.atsc_information",
        "atsc.atrc_release_code",
        "atsc.audio_type",
        "atsc.audio_service_type",
        "atsc.mixing_level",
        "atsc.surround_mode",
        "atsc.hierarchy_descriptor",
        "atsc.registration_descriptor",
        "atsc.data_stream_alignment_descriptor",
        "atsc.target_background_descriptor",
        "atsc.video_stream_descriptor",
        "atsc.audio_stream_descriptor",
        "atsc.hierarchy_descriptor",
        "atsc.content_descriptor",
        "atsc.parental_rating_descriptor",
        "atsc.teletext_descriptor",
        "atsc.subtitling_descriptor",
        "atsc.terrestrial_delivery_system_descriptor",
        "atsc.multiple_frame_rate_descriptor",
        "atsc.digital_teletext_descriptor",
        "atsc.stuffing_descriptor",
        "atsc.private_data_indicator_descriptor",
        "atsc.service_move_descriptor",
        "atsc.short_smoothing_buffer_descriptor",
        "atsc.scte35_descriptor",
        "atsc.extension_descriptor",
        "atsc.caption_service_descriptor",
        "atsc.content_advisory_descriptor",
        "atsc.revision_detection_descriptor",
        "atsc.two_part_channel_number_descriptor",
        "atsc.c_channel_number_descriptor",
        "atsc.enhanced_teletext_descriptor",
        "atsc.event_extended_text_descriptor",
        "atsc.extended_channel_name_descriptor",
        "atsc.program_identifier_descriptor",
        "atsc.loss_of_video_descriptor",
        "atsc.multiprotocol_encapsulation_descriptor",
        "atsc.dcc_departing_request_descriptor",
        "atsc.dcc_arrival_request_descriptor",
        "atsc.diagnostic_monitor_descriptor",
        "atsc.rcs_content_descriptor",
    ]

    return sorted(fields)


def get_dvb_fields() -> List[str]:
    """Get DVB-S/T/C digital video metadata fields."""

    fields = [
        "dvb.transport_stream_id",
        "dvb.original_network_id",
        "dvb.service_id",
        "dvb.service_type",
        "dvb.service_name",
        "dvb.service_provider_name",
        "dvb.service_logo",
        "dvb.pcr_pid",
        "dvb.pmt_pid",
        "dvb.video_pid",
        "dvb.audio_pid",
        "dvb.teletext_pid",
        "dvb.subtitle_pid",
        "dvb.nit_pid",
        "dvb.sdt_pid",
        "dvb.bat_pid",
        "dvb.eit_pid",
        "dvb.rst_pid",
        "dvb.tdt_pid",
        "dvb.tot_pid",
        "dvb.dns_pid",
        "dvb.ipmp_pid",
        "dvb.table_id",
        "dvb.section_length",
        "dvb.section_number",
        "dvb.last_section_number",
        "dvb.service_type",
        "dvb.service_type_digital_tv",
        "dvb.service_type_digital_radio",
        "dvb.service_type_mosaic",
        "dvb.service_type_databroadcast",
        "dvb.service_type_rcs_map",
        "dvb.service_type_rcs_fallback",
        "dvb.service_type_tv_mosaic",
        "dvb.service_type_enhanced_tv",
        "dvb.service_type_avc_tv",
        "dvb.service_type_avc_radio",
        "dvb.frequency",
        "dvb.orbital_position",
        "dvb.west_east_flag",
        "dvb.polarization",
        "dvb.roll_off",
        "dvb.modulation_system",
        "dvb.modulation_type",
        "dvb.symbol_rate",
        "dvb.fec_inner",
        "dvb.fec_outer",
        "dvb.dvb_s2_symbol_rate",
        "dvb.dvb_s2_fec",
        "dvb.dvb_s2_pilot",
        "dvb.dvb_s2_interleaving",
        "dvb.dvb_t_bandwidth",
        "dvb.dvb_t_constellation",
        "dvb.dvb_t_hierarchy",
        "dvb.dvb_t_code_rate_hp",
        "dvb.dvb_t_code_rate_lp",
        "dvb.dvb_t_guard_interval",
        "dvb.dvb_t_transmission_mode",
        "dvb.dvb_t2_frequency",
        "dvb.dvb_t2_plp_id",
        "dvb.dvb_t2_plp_type",
        "dvb.dvb_t2_plp_group_id",
        "dvb.dvb_t2_t2mi_packets",
        "dvb.dvb_t2_siso_miso",
        "dvb.dvb_c_frequency",
        "dvb.dvb_c_symbol_rate",
        "dvb.dvb_c_modulation",
        "dvb.dvb_c_fec_inner",
        "dvb.descriptor_tag",
        "dvb.descriptor_length",
        "dvb.network_name_descriptor",
        "dvb.service_list_descriptor",
        "dvb.stuffing_descriptor",
        "dvb.satellite_delivery_descriptor",
        "dvb.cable_delivery_descriptor",
        "dvb.vbi_data_descriptor",
        "dvb.vbi_teletext_descriptor",
        "dvb.bouquet_name_descriptor",
        "dvb.service_descriptor",
        "dvb.country_availability_descriptor",
        "dvb.linkage_descriptor",
        "dvb.nvod_reference_descriptor",
        "dvb.time_shifted_service_descriptor",
        "dvb.short_event_descriptor",
        "dvb.extended_event_descriptor",
        "dvb.teletext_descriptor",
        "dvb.subtitling_descriptor",
        "dvb.terrestrial_delivery_descriptor",
        "dvb.multilingual_service_name_descriptor",
        "dvb.private_data_specifier_descriptor",
        "dvb.service_move_descriptor",
        "dvb.short_smoothing_buffer_descriptor",
        "dvb.frequency_list_descriptor",
        "dvb.partial_transport_stream_descriptor",
        "dvb.data_broadcast_descriptor",
        "dvb.scrambling_descriptor",
        "dvb.data_broadcast_id_descriptor",
        "dvb.transport_stream_descriptor",
        "dvb.dsng_descriptor",
        "dvb.pdc_descriptor",
        "dvb.cell_list_descriptor",
        "dvb.cell_frequency_link_descriptor",
        "dvb.announcement_support_descriptor",
        "dvb.application_signal_descriptor",
        "dvb.service_identifier_descriptor",
        "dvb.service_kind_descriptor",
        "dvb.mhp_ait_descriptor",
        "dvb.mhp_oaig_descriptor",
        "dvb.stream_identifier_descriptor",
        "dvb.ca_identifier_descriptor",
        "dvb.content_descriptor",
        "dvb.parental_rating_descriptor",
        "dvb.extended_descriptor",
        "dvb.logo_transmission_descriptor",
        "dvb.mosaic_descriptor",
        "dvb.hierarchical_transmission_descriptor",
        "dvb.dvb_html_descriptor",
        "dvb.cpcm_delivery_signalling_descriptor",
        "dvb.cpcm_content_id_descriptor",
        "dvb.application_descriptor",
        "dvb.application_name_descriptor",
        "dvb.application_control_code_descriptor",
        "dvb.transport_profile_descriptor",
        "dvb.mhp_objects_descriptor",
        "dvb.mhp_registry_descriptor",
        "dvb.mhp_ip_signalling_descriptor",
        "dvb.mhp_label_descriptor",
        "dvb.mhp_stub_descriptor",
        "dvb.mhp_promotion_descriptor",
        "dvb.mhp_parental_rating_descriptor",
        "dvb.sbtvd_descriptor",
        "dvb.ait_descriptor",
        "dvb.mpe_fec_descriptor",
        "dvb.dii_descriptor",
        "dvb.ddb_descriptor",
        "dvb.selection_information_descriptor",
        "dvb.cdt_content_descriptor",
        "dvb.mpt_mode_descriptor",
        "dvb.conditional_playback_descriptor",
    ]

    return sorted(fields)


def get_isdm_fields() -> List[str]:
    """Get ISDB-T/S/B digital broadcasting metadata fields."""

    fields = [
        "isdm.transport_stream_id",
        "isdm.original_network_id",
        "isdm.service_id",
        "isdm.service_type",
        "isdm.service_name",
        "isdm.service_provider_name",
        "isdm.audio_component_type",
        "isdm.audio_component_tag",
        "isdm.audio_es_pid",
        "isdm.video_component_tag",
        "isdm.video_es_pid",
        "isdm.data_component_tag",
        "isdm.data_es_pid",
        "isdm.conditional_access",
        "isdm.earth_orbit_position",
        "isdm.antenna_azimuth",
        "isdm.antenna_elevation",
        "isdm.af_center_frequency",
        "isdm.strmid_ref",
        "isdm.strmid_value",
        "isdm.longitude_sign",
        "isdm.longitude",
        "isdm.latitude_sign",
        "isdm.latitude",
        "isdm.transmission_type",
        "isdm.number_of_services",
        "isdm.terrestrial_delivery_system",
        "isdm.shs_service_type",
        "isdm.shs_ts_information",
        "isdm.shs_type_specifier",
        "isdm.shs_component_tag",
        "isdm.shs_group_id",
        "isdm.shs_number_of_components",
        "isdm.shs_emergency_broadcast",
        "isdm.component_group",
        "isdm.component_group_type",
        "isdm.component_group_id",
        "isdm.component_group_name",
        "isdm.audio_component_group_id",
        "isdm.video_component_group_id",
        "isdm.multiple_stream_type",
        "isdm.multiple_audio_type",
        "isdm.audio_mode",
        "isdm.sampling_rate",
        "isdb_main_flag",
        "isdm.main_component",
        "isdm.audio_service_type",
        "isdm.audio_service_type_rc",
        "isdm.audio_service_type_radiotext",
        "isdm.audio_service_type_memo",
        "isdm.audio_service_type_mix",
        "isdm.audio_service_type_voice_comment",
        "isdm.audio_language_code",
        "isdm.video_display_format",
        "isdm.aspect_ratio",
        "isdm.component_tag",
        "isdm.stream_type",
        "isdm.elementary_pid",
        "isdm.oca_bits",
        "isdm.main_video_flag",
        "isdm.conditional_access_b4",
        "isdm.user_defined_descriptor",
        "isdm.digital_copy_control_descriptor",
        "isdm.audio_recording_control_descriptor",
        "isdm.max_bitrate_descriptor",
        "isdm.video_decode_control_descriptor",
        "isdm.audio_decode_control_descriptor",
        "isdm.content_availability_descriptor",
        "isdm.component_descriptor",
        "isdm.accumulated_program_time_descriptor",
        "isdm.broadcaster_name_descriptor",
        "isdm.partial_transport_stream_descriptor",
        "isdm.audio_component_descriptor",
        "isdm.data_content_descriptor",
        "isdm.contents_descriptor",
        "isdb_linking_descriptor",
        "isdm.terrestrial_delivery_system_descriptor",
        "isdm.partial_receive_descriptor",
        "isdm.emergency_information_descriptor",
        "isdm.component_group_descriptor",
        "isdm.shs_service_group_descriptor",
        "isdm.free_time_counter_descriptor",
        "isdm.hierarchical_reception_descriptor",
        "isdm.system_management_descriptor",
        "isdm.registration_descriptor",
        "isdm.stuffing_descriptor",
        "isdm.private_data_specifier_descriptor",
        "isdm.service_descriptor",
        "isdm.short_event_descriptor",
        "isdm.extended_event_descriptor",
        "isdm.time_shifted_event_descriptor",
        "isdm.ca_descriptor",
        "isdm.descriptor_tag_extension",
        "isdm.ts_information_descriptor",
        "isdm.short_basic_event_descriptor",
        "isdm.reference_event_descriptor",
        "isdm.related_event_descriptor",
        "isdm.transmission_format_ratio_descriptor",
        "isdm.lc_url_descriptor",
        "isdm.emergency_broadcast_descriptor",
        "isdm.structure_descriptor",
        "isdm.multimedia_service_info_descriptor",
        "isdm.multimedia_service_descriptors",
        "isdm.caption_content_descriptor",
        "isdm.audio_caption_service_descriptor",
        "isdm.content_availability_descriptor",
        "isdm.service_group_descriptor",
    ]

    return sorted(fields)


def get_smpte_fields() -> List[str]:
    """Get SMPTE timecode, video metadata, and color bar fields."""

    fields = [
        "smpte.timecode",
        "smpte.source_timecode",
        "smpte.record_timecode",
        "smpte.drop_frame_flag",
        "smpte.frame_count",
        "smpte.hours",
        "smpte.minutes",
        "smpte.seconds",
        "smpte.frames",
        "smpte.bit_frames",
        "smpte.user_bits",
        "smpte.biphase_mark",
        "smpte.rp188_timecode",
        "smpte.ltc",
        "smpte.vitc",
        "smpte.ancillary_timecode",
        "smpte.color_bar_type",
        "smpte.color_bar_enabled",
        "smpte.chrominance_100",
        "smpte.chrominance_75",
        "smpte.luminance_levels",
        "smpte.white_level",
        "smpte.black_level",
        "smpte.blank_level",
        "smpte.sync_level",
        "smpte.color_burst",
        "smpte.video_signal_type",
        "smpte.active_video",
        "smpte.total_lines",
        "smpte.active_lines",
        "smpte.horizontal_blanking",
        "smpte.vertical_blanking",
        "smpte.pixel_aspect_ratio",
        "smpte.frame_rate",
        "smpte.scan_type",
        "smpte.interlace_mode",
        "smpte.field_order",
        "smpte.chroma_subsampling",
        "smpte.color_primaries",
        "smpte.transfer_characteristics",
        "smpte.matrix_coefficients",
        "smpte.video_bit_depth",
        "smpte.video_bit_rate",
        "smpte.video_codec",
        "smpte.compression_scheme",
        "smpte.digital_source_signal_type",
        "smpte.digital_source_device",
        "smpte.image_offset",
        "smpte.image_center",
        "smpte.capture_gamma",
        "smpte.encoding_parameters",
        "smpte.film_type",
        "smpte.film_frame_rate",
        "smpte.film_perforations_frame",
        "smpte.film_perforations_length",
        "smpte.film_cinema_camera_aperture",
        "smpte.film_projector_aperture",
        "smpte.film_aspect_ratio",
        "smpte.safe_area",
        "smpte.title_safe_area",
        "smpte.action_safe_area",
        "smpte.graphic_safe_area",
        "smpte.broadcast_safe_area",
        "smpte.line_map",
        "smpte.active_format_descriptor",
        "smpte.afd_bar_data",
        "smpte.bar_transform",
        "smpte.bar_values",
        "smpte.closed_captioning",
        "smpte.cea_608",
        "smpte.cea_708",
        "smpte.wss",
        "smpte.vps",
        "smpte.timecode_source",
        "smpte.timecode_block_number",
        "smpte.timecode_flags",
        "smpte.cddb_timecode",
        "smpte.tape_date",
        "smpte.tape_time",
        "smpte.slate information",
        "smpte.scene_number",
        "smpte.take_number",
        "smpte.camera_operator",
        "smpte.director",
        "smpte.copyright",
        "smpte.company_name",
        "smpte.product_name",
        "smpte.product_version",
        "smpte.creation_date",
        "smpte.modification_date",
        "smpte.umid",
        "smpte.unique_material_identifier",
        "smpte.generation_id",
        "smpte.user_date_time",
        "smpte.tape_format",
        "smpte.tape_playback_speed",
        "smpte.tape_stock",
        "smpte.log_comment",
        "smpte.shot_marker",
        "smpte.good_take",
        "smpte.wide_screen_ratio",
        "smpte.video_standard",
        "smpte.black_ref_level",
        "smpte.white_ref_level",
        "smpte.color_range",
        "smpte.picture_start_code",
        "smpte.video_end_code",
    ]

    return sorted(fields)


def get_mpegts_fields() -> List[str]:
    """Get MPEG Transport Stream metadata fields."""

    fields = [
        "mpegts.pid",
        "mpegts.transport_stream_id",
        "mpegts.original_network_id",
        "mpegts.program_number",
        "mpegts.pcr_pid",
        "mpegts.pmt_pid",
        "mpegts.cat_pid",
        "mpegts.nit_pid",
        "mpegts.sdt_pid",
        "mpegts.bat_pid",
        "mpegts.eit_pid",
        "mpegts.rst_pid",
        "mpegts.tdt_pid",
        "mpegts.tot_pid",
        "mpegts.dns_pid",
        "mpegts.ipmp_pid",
        "mpegts.table_id",
        "mpegts.section_length",
        "mpegts.section_number",
        "mpegts.last_section_number",
        "mpegts.version_number",
        "mpegts.current_next_indicator",
        "mpegts.section_syntax_indicator",
        "mpegts.private_indicator",
        "mpegts.sync_byte",
        "mpegts.transport_error_indicator",
        "mpegts.payload_unit_start_indicator",
        "mpegts.transport_priority",
        "mpegts.transport_scrambling_control",
        "mpegts.adaptation_field_control",
        "mpegts.continuity_counter",
        "mpegts.pat_table_id",
        "mpegts.pat_transport_stream_id",
        "mpegts.pat_program_number",
        "mpegts.pat_program_map_pid",
        "mpegts.pmt_table_id",
        "mpegts.pmt_pcr_pid",
        "mpegts.pmt_program_info_length",
        "mpegts.pmt_stream_type",
        "mpegts.pmt_elementary_pid",
        "mpegts.pmt_es_info_length",
        "mpegts.cat_descriptors",
        "mpegts.nit_network_id",
        "mpegts.nit_network_descriptor_length",
        "mpegts.nit_descriptors",
        "mpegts.sdt_actual_transport_stream_id",
        "mpegts.sdt_actual_service_id",
        "mpegts.eit_present_following",
        "mpegts.eit_schedule",
        "mpegts.eit_event_id",
        "mpegts.eit_start_time",
        "mpegts.eit_duration",
        "mpegts.tdt_time_utc",
        "mpegts.tot_time_utc",
        "mpegts.adaptation_field_length",
        "mpegts.discontinuity_indicator",
        "mpegts.random_access_indicator",
        "mpegts.elementary_stream_priority_indicator",
        "mpegts.pcr_flag",
        "mpegts.opcr_flag",
        "mpegts.splicing_point_flag",
        "mpegts.transport_private_data_flag",
        "mpegts.adaptation_field_extension_flag",
        "mpegts.pcr_base",
        "mpegts.pcr_extension",
        "mpegts.opcr_base",
        "mpegts.opcr_extension",
        "mpegts.splice_countdown",
        "mpegts.transport_private_data_length",
        "mpegts.adaptation_field_data_length",
        "mpegts.splice_type",
        "mpegts.dts_next_au",
        "mpegts.au_index",
        "mpegts.au_index_difference",
        "mpegts.splice_immediate_flag",
        "mpegts.inband_header_flag",
        "mpegts.private_data_flag",
        "mpegts.stuffing_byte",
        "mpegts.null_packet",
        "mpegts.packet_size",
        "mpegts.bit_rate",
        "mpegts.duration",
        "mpegts.continuity_check",
        "mpegts.pes_start_code",
        "mpegts.pes_stream_id",
        "mpegts.pes_packet_length",
        "mpegts.pes_scrambling_control",
        "mpegts.pes_priority",
        "mpegts.data_alignment_indicator",
        "mpegts.copyright",
        "mpegts.original_or_copy",
        "mpegts.pts_dts_flags",
        "mpegts.escr_flag",
        "mpegts.es_rate_flag",
        "mpegts.trick_mode_flag",
        "mpegts.additional_copy_info_flag",
        "mpegts.pes_crc_flag",
        "mpegts.pes_extension_flag",
        "mpegts.pes_header_data_length",
        "mpegts.pts_32_30",
        "mpegts.pts_29_15",
        "mpegts.pts_14_0",
    ]

    return sorted(fields)


def get_broadcast_automation_fields() -> List[str]:
    """Get broadcast automation scheduling, rundown, and production metadata fields."""

    fields = [
        "automation.scheduled_time",
        "automation.scheduled_duration",
        "automation.actual_start_time",
        "automation.actual_end_time",
        "automation.estimated_duration",
        "automation.rundown_order",
        "automation.rundown_position",
        "automation.rundown_name",
        "automation.rundown_id",
        "automation.rundown_type",
        "automation.show_code",
        "automation.show_name",
        "automation.episode_code",
        "automation.season_number",
        "automation.episode_number",
        "automation.segment_number",
        "automation.segment_name",
        "automation.segment_type",
        "automation.segment_duration",
        "automation.segment_start",
        "automation.item_type",
        "automation.item_name",
        "automation.item_id",
        "automation.source_id",
        "automation.source_name",
        "automation.source_type",
        "automation.clip_id",
        "automation.clip_name",
        "automation.clip_path",
        "automation.clip_duration",
        "automation.clip_in",
        "automation.clip_out",
        "automation.playlist_id",
        "automation.playlist_position",
        "automation.transition_type",
        "automation.transition_duration",
        "automation.cue_points",
        "automation.key_frames",
        "automation.markers",
        "automation.sub_rundowns",
        "automation.block_id",
        "automation.block_name",
        "automation.block_type",
        "automation.live_source",
        "automation.live_take",
        "automation.live_status",
        "automation.on_air_status",
        "automation.next_up_status",
        "automation.breaking_news",
        "automation.emergency_alert",
        "automation.override_status",
        "automation.manual_control",
        "automation.operator_id",
        "automation.operator_name",
        "automation.station_id",
        "automation.station_name",
        "automation.channel_id",
        "automation.channel_name",
        "automation.channel_number",
        "automation.destination",
        "automation.output_format",
        "automation.output_resolution",
        "automation.output_codec",
        "automation.recording_status",
        "automation.recording_path",
        "automation.capture_time",
        "automation.capture_device",
        "automation.ingest_status",
        "automation.ingest_time",
        "automation.qa_status",
        "automation.qa_notes",
        "automation.approvals",
        "automation.approval_status",
        "automation.approved_by",
        "automation.approved_time",
        "automation.last_modified",
        "automation.modified_by",
        "automation.version_number",
        "automation.lock_status",
        "automation.locked_by",
        "automation.comments",
        "automation.notes",
        "automation.tags",
        "automation.categories",
        "automation.genre",
        "automation.rating",
        "automation.content_flags",
        "automation.restrictions",
        "automation.rights_start",
        "automation.rights_end",
        "automation.rights_territory",
    ]

    return sorted(fields)


def get_radio_rds_fields() -> List[str]:
    """Get FM radio, RDS PS, RT, CT metadata fields."""

    fields = [
        "rds.program_service_name",
        "rds.ps_name",
        "rds.program_type",
        "rds.ptc_code",
        "rds.radio_text",
        "rds.rt_text",
        "rds.cta_text",
        "rds.clock_time",
        "rds.ct_time",
        "rds.ct_date",
        "rds.ct_offset",
        "rds.traffic_announcement",
        "rds.ta_code",
        "rds.traffic_program",
        "rds.tp_code",
        "rds.music_speech",
        "rds.mu_sp_flag",
        "rds.decoder_country_code",
        "rds.dcc_code",
        "rds.program_identification",
        "rds.pi_code",
        "rds.ecc_code",
        "rds.country_code",
        "rds.coverage_area",
        "rds.pilot_tone",
        "rds.stereo_mono",
        "rds.stereo_flag",
        "rds.artificial_head",
        "rds.compressed",
        "rds.dynamic_pty",
        "rds.pty_static",
        "rds.program_hierarchy",
        "rds.lfm",
        "rds.national_code",
        "rds.regional_code",
        "rds.af_list",
        "rds.af_method",
        "rds.af_count",
        "rds.af_a",
        "rds.af_b",
        "rds.enhanced_other_network",
        "rds.eon_ypi_code",
        "rds.eon_ps_name",
        "rds.eon_frequency",
        "rds.eon_pi_code",
        "rds.eon_tp_flag",
        "rds.eon_ta_flag",
        "rds.eon_ms_flag",
        "rds.eon_pty_code",
        "rds.radiotext_plus",
        "rds.rt_plus_flag",
        "rds.rt_item_address",
        "rds.rt_item_value",
        "rds.enhanced_radio_text",
        "rds.ert_a",
        "rds.ert_b",
        "rds.ert_group_type",
        "rds.ert_segment",
        "rds.ert_start_address",
        "rds.ert_content_type",
        "rds.ert_text",
        "rds.opaque_data",
        "rds.group_type",
        "rds.version_code",
        "rds.group_version",
        "rds.ab_flag",
        "rds.tp_flag",
        "rds.m/s_flag",
        "rds.t/a_flag",
        "rds.spare_flag",
        "rds.data_group_length",
        "rds.rds_data",
        "rds.rds_version",
        "rds.rbds",
        "rds.special_headline",
        "rds.information_type",
        "rds.location_identifier",
        "rds.ews_alert",
        "rds.ews_id",
        "rds.ews_scope",
        "rds.ews_severity",
        "rds.ews_certainty",
        "rds.ews_type",
        "rds.ews_expires",
        "rds.ews_sender",
        "rds.ews_message",
        "rds.frequency",
        "rds.frequency_list",
        "rds.signal_strength",
        "rds.signal_quality",
        "rds.bit_error_rate",
        "rds.group_error_rate",
        "rds.sync_status",
        "rds.decode_status",
    ]

    return sorted(fields)


def generate_inventory(output_dir: Path) -> None:
    """Generate broadcast/TV/radio metadata field inventory."""

    output_dir.mkdir(parents=True, exist_ok=True)

    inventory = {
        "generated_at": "",
        "source": "specification",
        "categories": {},
        "totals": {},
    }

    from datetime import datetime, timezone
    inventory["generated_at"] = datetime.now(timezone.utc).isoformat(timespec="seconds")

    # ATSC/数字电视
    atsc_fields = get_atsc_fields()
    inventory["categories"]["ATSC_Digital_TV"] = {
        "category": "ATSC/数字电视",
        "description": "ATSC A/53, A/65, A/71 standards, broadcast PSIP",
        "fields": atsc_fields,
        "field_count": len(atsc_fields),
    }

    # DVB/欧洲数字视频
    dvb_fields = get_dvb_fields()
    inventory["categories"]["DVB_European_Digital"] = {
        "category": "DVB/欧洲数字视频",
        "description": "DVB-S/T/C standards, MPEG transport stream",
        "fields": dvb_fields,
        "field_count": len(dvb_fields),
    }

    # ISDB/日本数字广播
    isdb_fields = get_isdm_fields()
    inventory["categories"]["ISDB_Japanese_Broadcast"] = {
        "category": "ISDB/日本数字广播",
        "description": "ISDB standards, digital broadcasting",
        "fields": isdb_fields,
        "field_count": len(isdb_fields),
    }

    # SMPTE
    smpte_fields = get_smpte_fields()
    inventory["categories"]["SMPTE"] = {
        "category": "SMPTE",
        "description": "SMPTE timecodes, video metadata, color bars",
        "fields": smpte_fields,
        "field_count": len(smpte_fields),
    }

    # MPEG-TS
    mpegts_fields = get_mpegts_fields()
    inventory["categories"]["MPEG_TS"] = {
        "category": "MPEG-TS",
        "description": "MPEG transport stream, PAT, PMT, CAT tables",
        "fields": mpegts_fields,
        "field_count": len(mpegts_fields),
    }

    # Broadcast Automation
    automation_fields = get_broadcast_automation_fields()
    inventory["categories"]["Broadcast_Automation"] = {
        "category": "Broadcast Automation",
        "description": "scheduling, rundown, production metadata",
        "fields": automation_fields,
        "field_count": len(automation_fields),
    }

    # Radio/RDS
    rds_fields = get_radio_rds_fields()
    inventory["categories"]["Radio_RDS"] = {
        "category": "Radio/RDS",
        "description": "FM radio, RDS PS, RT, CT fields",
        "fields": rds_fields,
        "field_count": len(rds_fields),
    }

    # Calculate totals
    total_fields = (
        len(atsc_fields) + len(dvb_fields) + len(isdb_fields) +
        len(smpte_fields) + len(mpegts_fields) + len(automation_fields) +
        len(rds_fields)
    )

    inventory["totals"] = {
        "categories": len(inventory["categories"]),
        "total_fields": total_fields,
    }

    # Write broadcast_inventory.json
    output_path = output_dir / "broadcast_inventory.json"
    output_path.write_text(json.dumps(inventory, indent=2, sort_keys=True), encoding="utf-8")
    print(f"Wrote: {output_path}")

    # Generate summary
    summary = {
        "generated_at": inventory["generated_at"],
        "total_fields": total_fields,
        "total_categories": len(inventory["categories"]),
        "by_category": {},
    }

    for cat_key, cat_data in inventory["categories"].items():
        summary["by_category"][cat_data["category"]] = {
            "field_count": cat_data["field_count"],
            "description": cat_data["description"],
        }

    # Write broadcast_summary.json
    summary_path = output_dir / "broadcast_summary.json"
    summary_path.write_text(json.dumps(summary, indent=2, sort_keys=True), encoding="utf-8")
    print(f"Wrote: {summary_path}")

    print(f"Total fields: {total_fields}")


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="Generate broadcast/TV/radio metadata field inventory",
    )
    parser.add_argument(
        "--out-dir",
        type=Path,
        default=Path("dist/broadcast_inventory"),
        help="Output directory (default: dist/broadcast_inventory)",
    )
    args = parser.parse_args()

    generate_inventory(args.out_dir)


if __name__ == "__main__":
    main()
